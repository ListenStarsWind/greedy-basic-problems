# [最大数](https://leetcode.cn/problems/largest-number/)

![image-20250430153128975](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250430153129019.png)

## 题目解析

给你一组数, 你需要把它们排列形成一个新的数, 返回能够形成的最大数. 比如, 对于`[10, 2]`来说, 你可以把它们排列合成一个`102`, 也可以排列合成一个`210`, 返回其中最大的`210`

## 算法原理

这其实是道排序题, 只不过比较大小的规则需要我们自己定义. 排序本质上就是确定先后顺序, 我们再学习语言的时候, 想必也接触过控制大小定义的, 在`sort`等和元素顺序有关的函数对象`compare`, 传入两个对象, 记为`x, y`, 如果想让`x`排在`y`前面, 那就返回`true`, 否则就返回`false`, 之后我们也会使用这种方式, 将我们的大小定义传入`sort`中

我们先看一下普通的排序, 对`[4, 10, 8]`进行降序排列
我们随便这一个基准值, 比如就是`8`, 那么就会把`4`放到`8`的右边, `10`放到`8`的左面, 得到`[10, 8, 4]`
我们看到, 这些排序算法, 本质上都是依据转入的对象, 判断它俩的先后顺序, 对其中的两两元素调整顺序.
![image-20250430155324477](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250430155324521.png)

接下来看一下本题的比较策略

![image-20250430160827961](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250430160828036.png)

本题位于贪心专题中, 但上面的思路似乎没有贪心, 实际上是有的, 排序本身其实就是一种贪心思想, 因为它大, 所以我放前面, 本题的贪心隐藏在排序中.

另外一个非常容易忽略的点是, 不是说有大小比较就一定可以排序, 这是需要证明的, 我们的排序规则其实暗含着一个条件, 那就是排序对象具有传递性, 如果`a > b, b > c`, 则一定要有`a > c`, 如果推不出, 就说明, `a`既可以在`b`前面, 也可以在`c`前面, 但`b`一定要在`c`前面, 此时就不能确保先后顺序的唯一性, 所以无法进行排序.

## 代码编写

有一个细节需要知道, 示例给的那组数可能是一堆零, 这样就会拼出来`00000000`, 这种字符串, 此时我们只要返回一个`0`即可, 这种情况是数组中全部为零才会发生, 对于其它情况, 由于有正数的存在, 所以一定桑正数开头, 不会是零开头.

```cpp
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        vector<string> ss;
        for(auto e : nums) ss.push_back(to_string(e));

        sort(ss.begin(), ss.end(), [](const string& x, const string& y){
            return x + y > y + x;
        });

        string result;
        for(auto e : ss) result += e;

        return result[0] == '0' ? "0" : result;
    }
};
```

## 证明

![image-20250430171503957](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250430171504320.png)

# 完

